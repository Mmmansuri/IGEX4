<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Downtown Office Tower - IGEX4 Project</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Particle background -->
    <div class="stars-container" id="starsContainer"></div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <div class="logo">
                <a href="../igex4-index.html" style="text-decoration: none; color: inherit; display: flex; align-items: center;">
                    <img src="../assets/images/logo.png" alt="IGEX4" style="height: 35px; margin-right: 10px;">
                    <span style="font-size: 20px; font-weight: 700; color: #1a1a1a;">IGEX<span style="color: #00A3E0;">4</span></span>
                </a>
            </div>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../igex4-index.html#home">Home</a></li>
                <li><a href="../igex4-index.html#services">Services</a></li>
                <li><a href="../igex4-index.html#projects">Projects</a></li>
                <li><a href="../igex4-index.html#technology">Technology</a></li>
                <li><a href="../igex4-index.html#why-choose">Why Us</a></li>
                <li><a href="../igex4-index.html#cta">Contact</a></li>
            </ul>
            <div class="hamburger" id="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="page-wrapper">
        <!-- Canvas with Layers Inside -->
        <div class="canvas-wrapper">
            <div id="container">
                <!-- Canvas Controls -->
                <div class="canvas-bg-toggle">
                    <div class="toggle-row">
                        <span class="canvas-bg-label">Dark Mode</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="canvasBgToggle" onchange="toggleCanvasBackground()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="toggle-row">
                        <span class="canvas-bg-label">Fullscreen</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="fullscreenToggle" onchange="toggleFullscreen()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <button class="reset-view-btn" onclick="resetView()">Reset View</button>
                </div>

                <canvas id="canvas"></canvas>
                
                <!-- View Controls -->
                <div id="controls">
                    <h4>View Controls</h4>
                    <div class="control-item">
                        <span class="control-label">Rotate:</span> Left Click + Drag
                    </div>
                    <div class="control-item">
                        <span class="control-label">Pan:</span> Right Click + Drag
                    </div>
                    <div class="control-item">
                        <span class="control-label">Zoom:</span> Mouse Scroll
                    </div>
                    <div class="control-item">
                        <span class="control-label">Navigate:</span> Arrow Keys
                    </div>
                </div>
            </div>
        </div>

        <!-- About Section with Stats -->
        <div class="about-section">
            <h3>About This Project</h3>
            <p>This structural analysis visualization displays a detailed electrical room structural model exported from ETABS. The 3D rendering allows for comprehensive examination of the structural components with real-time interaction capabilities. Engineers can rotate, pan, and zoom to inspect every aspect of the design, facilitating better understanding of spatial relationships and structural integrity.</p>
            
            <div class="project-stats">
                <div class="stat-card">
                    <div class="stat-label">Source</div>
                    <div class="stat-value">ETABS</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Model Type</div>
                    <div class="stat-value">ER-mem</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Coordinate System</div>
                    <div class="stat-value">Z-Up</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Render Mode</div>
                    <div class="stat-value">Interactive</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h4>IGEX4</h4>
                <p style="margin-bottom: 15px;">Building Tomorrow's Infrastructure Today</p>
                <p>Expert structural analysis and design services for complex projects worldwide.</p>
            </div>
            
            <div class="footer-section">
                <h4>Navigation</h4>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <a href="../igex4-index.html#home">Home</a>
                    <a href="../igex4-index.html#services">Services</a>
                    <a href="../igex4-index.html#projects">Projects</a>
                    <a href="../igex4-index.html#technology">Technology</a>
                    <a href="../igex4-index.html#why-choose">Why Us</a>
                    <a href="../igex4-index.html#cta">Contact</a>
                </div>
            </div>
        </div>
        
        <div class="footer-bottom">
            <p>&copy; 2024 IGEX4. All rights reserved.</p>
        </div>
    </footer>

    <!-- Three.js and TrackballControls -->
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script>

    <script>
        // ============================================
        // GLOBAL VARIABLES
        // ============================================
        let scene, camera, renderer, clock;
        let structure, gridHelper;
        let trackballControls;
        let geometryData = null;
        let buildingBounds = null;
        let buildingCenter = null;
        let buildingMaxSize = null;
        let initialCameraPosition = null;
        let initialCameraTarget = null;
        let keys = {};
        let moveSpeed = 0.3;
        let canvasHasFocus = false;

        // ============================================
        // FILE LOADING
        // ============================================
        async function loadModelFromFile() {
            try {
                const response = await fetch('model.html');
                const htmlText = await response.text();
                loadModelFromHTML(htmlText);
            } catch (error) {
                console.error('Error loading model.html:', error);
                alert('Could not load model.html file. Please make sure it exists in the same directory.');
            }
        }

        function loadModelFromHTML(htmlText) {
            // Clear existing
            if (structure) scene.remove(structure);
            if (gridHelper) scene.remove(gridHelper);
            
            // Extract vertex data
            const vertexMatch = htmlText.match(/var vertices = new Float32Array\(\[([\s\S]*?)\]\);/);
            const colorMatch = htmlText.match(/var clr1 = new Float32Array\(\[([\s\S]*?)\]\);/);
            
            if (!vertexMatch || !colorMatch) {
                alert('Could not find geometry data. Please select a valid ETABS HTML export.');
                return;
            }
            
            // Parse data
            const vertices = new Float32Array(vertexMatch[1].split(',').map(parseFloat));
            const colors = new Float32Array(colorMatch[1].split(',').map(parseFloat));
            
            console.log('Loading model:', vertices.length / 3, 'vertices');
            
            // Store geometry data
            geometryData = { vertices, colors };
            
            // Calculate bounds
            buildingBounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity,
                minZ: Infinity, maxZ: -Infinity
            };
            
            for (let i = 0; i < vertices.length; i += 3) {
                buildingBounds.minX = Math.min(buildingBounds.minX, vertices[i]);
                buildingBounds.maxX = Math.max(buildingBounds.maxX, vertices[i]);
                buildingBounds.minY = Math.min(buildingBounds.minY, vertices[i + 1]);
                buildingBounds.maxY = Math.max(buildingBounds.maxY, vertices[i + 1]);
                buildingBounds.minZ = Math.min(buildingBounds.minZ, vertices[i + 2]);
                buildingBounds.maxZ = Math.max(buildingBounds.maxZ, vertices[i + 2]);
            }
            
            buildingCenter = new THREE.Vector3(
                (buildingBounds.minX + buildingBounds.maxX) / 2,
                (buildingBounds.minY + buildingBounds.maxY) / 2,
                (buildingBounds.minZ + buildingBounds.maxZ) / 2
            );
            
            const sizeX = buildingBounds.maxX - buildingBounds.minX;
            const sizeY = buildingBounds.maxY - buildingBounds.minY;
            const sizeZ = buildingBounds.maxZ - buildingBounds.minZ;
            buildingMaxSize = Math.max(sizeX, sizeY, sizeZ);
            
            console.log('Building center:', buildingCenter);
            console.log('Building size:', buildingMaxSize);
            
            // Create centered geometry
            const centeredVertices = new Float32Array(vertices.length);
            for (let i = 0; i < vertices.length; i += 3) {
                centeredVertices[i] = vertices[i] - buildingCenter.x;
                centeredVertices[i + 1] = vertices[i + 1] - buildingCenter.y;
                centeredVertices[i + 2] = vertices[i + 2] - buildingCenter.z;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(centeredVertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });
            
            structure = new THREE.LineSegments(geometry, material);
            scene.add(structure);
            
            // Create grid
            const gridSize = buildingMaxSize * 2;
            gridHelper = new THREE.GridHelper(gridSize, 20, 0x00A3E0, 0xcccccc);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);
            
            // Setup camera
            const distance = buildingMaxSize * 2.5;
            camera.position.set(distance * 0.7, distance * 0.7, distance * 0.7);
            camera.lookAt(0, 0, 0);
            
            trackballControls.target.set(0, 0, 0);
            trackballControls.update();
            
            // Save initial camera position
            initialCameraPosition = camera.position.clone();
            initialCameraTarget = trackballControls.target.clone();
            
            console.log('Model loaded successfully');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);

            camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                10000
            );

            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            clock = new THREE.Clock();

            trackballControls = new THREE.TrackballControls(camera, canvas);
            trackballControls.rotateSpeed = 2.0;
            trackballControls.zoomSpeed = 1.2;
            trackballControls.panSpeed = 0.8;
            trackballControls.staticMoving = false;
            trackballControls.dynamicDampingFactor = 0.2;
            trackballControls.target = new THREE.Vector3(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 20);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-20, 20, -20);
            scene.add(directionalLight2);

            canvas.addEventListener('mouseenter', () => { canvasHasFocus = true; });
            canvas.addEventListener('mouseleave', () => { canvasHasFocus = false; });

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            animate();
            
            // Auto-load model.html
            loadModelFromFile();
        }

        // ============================================
        // KEYBOARD CONTROLS
        // ============================================
        function onKeyDown(e) {
            const key = e.key.toLowerCase();
            const code = e.code.toLowerCase();
            keys[key] = true;
            keys[code] = true;
            
            const navKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright'];
            if (canvasHasFocus && (navKeys.includes(key) || navKeys.includes(code))) {
                e.preventDefault();
            }
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
            keys[e.code.toLowerCase()] = false;
        }

        function updateWalkMovement() {
            if (!canvasHasFocus || !buildingMaxSize) return;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.z = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 0, 1)).normalize();

            let moved = false;
            
            if (keys['w'] || keys['arrowup']) {
                camera.position.addScaledVector(forward, moveSpeed);
                trackballControls.target.addScaledVector(forward, moveSpeed);
                moved = true;
            }
            if (keys['s'] || keys['arrowdown']) {
                camera.position.addScaledVector(forward, -moveSpeed);
                trackballControls.target.addScaledVector(forward, -moveSpeed);
                moved = true;
            }
            if (keys['a'] || keys['arrowleft']) {
                camera.position.addScaledVector(right, -moveSpeed);
                trackballControls.target.addScaledVector(right, -moveSpeed);
                moved = true;
            }
            if (keys['d'] || keys['arrowright']) {
                camera.position.addScaledVector(right, moveSpeed);
                trackballControls.target.addScaledVector(right, moveSpeed);
                moved = true;
            }
            
            if (moved) {
                trackballControls.update();
            }
        }

        // ============================================
        // UI CONTROLS
        // ============================================
        function toggleFullscreen() {
            const body = document.body;
            const toggle = document.getElementById('fullscreenToggle');
            
            if (toggle.checked) {
                body.classList.add('fullscreen-mode');
            } else {
                body.classList.remove('fullscreen-mode');
            }
            
            setTimeout(onWindowResize, 100);
        }

        function toggleCanvasBackground() {
            const container = document.getElementById('container');
            const toggle = document.getElementById('canvasBgToggle');
            
            if (toggle.checked) {
                container.classList.add('dark-canvas');
                scene.background = new THREE.Color(0x1a1a1a);
            } else {
                container.classList.remove('dark-canvas');
                scene.background = new THREE.Color(0xf8fafc);
            }
        }

        function resetView() {
            if (!initialCameraPosition || !trackballControls) {
                console.log('Cannot reset - missing initial values');
                return;
            }
            
            camera.position.copy(initialCameraPosition);
            trackballControls.target.copy(initialCameraTarget);
            trackballControls.update();
            
            if (structure) {
                structure.rotation.set(0, 0, 0);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            if (trackballControls) {
                trackballControls.handleResize();
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            updateWalkMovement();
            const delta = clock.getDelta();
            trackballControls.update(delta);
            renderer.render(scene, camera);
        }

        // ============================================
        // STARS/PARTICLES BACKGROUND
        // ============================================
        function createStars() {
            const container = document.getElementById('starsContainer');
            const numStars = 60;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                const size = 5;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + 'vh';
                star.style.animationDelay = Math.random() * 20 + 's';
                star.style.animationDuration = (15 + Math.random() * 10) + 's';
                
                container.appendChild(star);
            }
        }

        // Mobile menu toggle
        const hamburger = document.getElementById('hamburger');
        const navMenu = document.getElementById('navMenu');
        
        hamburger.addEventListener('click', () => 